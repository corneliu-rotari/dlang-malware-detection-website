import std.algorithm.searching;
import std.conv;
import std.digest;
import std.digest.sha;
import std.range;
import std.stdio;
import std.array;
import std.string;
import std.typecons;

import vibe.db.mongo.mongo : connectMongoDB, MongoClient, MongoCollection;
import vibe.data.bson;

import dauth : makeHash, toPassword, parseHash;

struct DBConnection
{
    enum UserRet
    {
        OK,
        ERR_NULL_PASS,
        ERR_USER_EXISTS,
        ERR_INVALID_EMAIL,
        ERR_WRONG_USER,
        ERR_WRONG_PASS,
        NOT_IMPLEMENTED
    }
    MongoClient client;
    MongoCollection user;

    this(string dbUser, string dbPassword, string dbAddr, string dbPort, string dbName)
    {
        this.client = connectMongoDB("mongodb://" ~ dbUser ~ ":" ~ dbPassword ~ "@" ~ dbAddr ~ ":" ~ dbPort ~"/");
        this.user = client.getCollection("testing.user");
    }

    bool vaildEmail(string email)
    {
        int at = -1, dot = -1;
        for (int i = 0; i < email.length; i++) {
        // If the character is '@'
            if (email[i] == '@') {
                at = i;
            }
            if (email[i] == '.') {
                dot = i;
            }
        }
        if (at == -1 || dot == -1)
            return false;
  
        if (at > dot)
            return false;
        if (at + 1 == dot)
            return false;
        if (email.length - dot <= 2) 
            return false;
        
        return true; 
    }

    UserRet addUser(string email, string username, string password, string name = "", string desc = "")
    {
        if (!vaildEmail(email)) {
            return UserRet.ERR_INVALID_EMAIL;
        } else if (password == null) {
            return UserRet.ERR_NULL_PASS;
        }

        auto found = user.findOne(["_id" : email]);
        if (found == Bson(null)) {
            user.insert(["_id" : email, "username":username, "password": password, "name" : name, "desc" : desc]);
            return UserRet.OK;
        }
        return UserRet.ERR_USER_EXISTS;
    }

    UserRet authUser(string email, string password)
    {
        if (!vaildEmail(email)) {
            return UserRet.ERR_INVALID_EMAIL;
        } else if (password == null) {
            return UserRet.ERR_NULL_PASS;
        }

        auto userInDb = this.user.findOne(["_id" : email]);

        if (userInDb == Bson(null)) {
            return UserRet.ERR_WRONG_USER;
        }
        char[] pass = password.dup;
        if (userInDb["password"] != Bson(password)) {
            return UserRet.ERR_WRONG_PASS;
        }
        return UserRet.OK;
    }

    UserRet deleteUser(string email)
    {
        auto found = user.findOne(["_id" : email]);
        if (found != Bson(null)) {
            user.remove(["_id" : email]);
            return UserRet.OK;
        }

        return UserRet.ERR_USER_EXISTS;
    }

    struct File
    {
        @name("_id") BsonObjectID id; // represented as _id in the db
        string userId;
        ubyte[] binData;
        string fileName;
        string digest;
        string securityLevel;

    }

    enum FileRet
    {
        OK,
        FILE_EXISTS,
        ERR_EMPTY_FILE,
        NOT_IMPLEMENTED
    }

    FileRet addFile(string userId, immutable ubyte[] binData, string fileName)
    {
        if (binData.length == 0) {
            return FileRet.ERR_EMPTY_FILE;
        }
        MongoCollection file = client.getCollection("testing.file");
        auto found = file.findOne(["fileName" : fileName]);
        if (found != Bson(null)) {
            return FileRet.FILE_EXISTS;
        }


        file.insert(["_id" : makeHash(toPassword(fileName.dup)).toString(), "digest" :digest!SHA512(binData).toHexString().to!string
        , "fileName" : fileName, "userId" : userId]);
        return FileRet.OK;
    }

    File[] getFiles(string userId)
    {
        MongoCollection file = client.getCollection("testing.file");
        File[] foundfiles;
        auto found = file.find(["userId": userId]);
        if (found.empty) {
            return null;
        }
        File fileToAdd;

        foreach(Bson doc; found){

            fileToAdd.userId = doc["userId"].to!string;
            fileToAdd.fileName = doc["fileName"].to!string;
            
            foundfiles ~= fileToAdd;
        }
        return foundfiles;
    }

    Nullable!File getFile(string digest)
    in(!digest.empty)
    do
    {
        Nullable!File file;
        File fileToRet;
        MongoCollection files = client.getCollection("testing.file");
        auto found = files.findOne(["digest" : digest]);

        if(found != Bson(null)){
            fileToRet.userId = found["userId"].to!string;
            fileToRet.fileName = found["fileName"].to!string;
            file = fileToRet;
        }
        return file;
    }

    void deleteFile(string digest)
    in(!digest.empty)
    do
    {
        MongoCollection file = client.getCollection("testing.file");
        file.remove(["digest" : digest]);
    }

    struct Url
    {
        @name("_id") BsonObjectID id; // represented as _id in the db
        string userId;
        string addr;
        string securityLevel;
        string[] aliases;
    }

    enum UrlRet
    {
        OK,
        URL_EXISTS,
        ERR_EMPTY_URL,
        NOT_IMPLEMENTED
    }

    UrlRet addUrl(string userId, string urlAddress)
    {
        
        if (urlAddress == null) {
            return UrlRet.ERR_EMPTY_URL;
        }
        MongoCollection url = client.getCollection("testing.url");
        auto found = url.findOne(["urlAdd" : urlAddress]);
        if (found != Bson(null)) {
            return UrlRet.URL_EXISTS;
        }
        url.insert(["_id" : makeHash(toPassword(urlAddress.dup)).toString(), "urlAdd" : urlAddress, "userId" : userId, "security" : "default", "alias" : "alias"]);
        return UrlRet.OK;
    }

    Url[] getUrls(string userId)
    {
        MongoCollection urlInDb = client.getCollection("testing.url");
        auto found = urlInDb.find(["userId" : userId]);
        if (found.empty) {
            return null;
        }

        Url[] urlsToRet;
        Url insertToList;
        foreach(Bson url; found) {
            insertToList.userId = url["userId"].to!string;
            insertToList.addr = url["urlAdd"].to!string;
            insertToList.securityLevel = url["security"].to!string;
            insertToList.aliases ~= url["alias"].to!string;
            urlsToRet ~= insertToList;
        }

        return urlsToRet;
    }

    Nullable!Url getUrl(string urlAddress)
    in(!urlAddress.empty)
    do
    {
        MongoCollection urlsInDb = client.getCollection("testing.url");
        auto found = urlsInDb.findOne(["urlAdd" : urlAddress]);
        Nullable!Url url;
        Url urlToRet;

        if (found != Bson(null)) {
            urlToRet.userId = found["userId"].to!string;
            urlToRet.addr = found["urlAdd"].to!string;
            urlToRet.securityLevel = found["security"].to!string;
            urlToRet.aliases ~= found["alias"].to!string;
            url = urlToRet;
        }

        return url;
    }

    void deleteUrl(string urlAddress)
    in(!urlAddress.empty)
    do
    {
        MongoCollection url = client.getCollection("testing.url");
        url.remove(["urlAdd" : urlAddress]);
    }
}
